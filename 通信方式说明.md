# 进程间通信方式说明

## 📌 当前实现：Unix Domain Socket（不是共享内存）

### 当前代码的工作流程

```
程序A（data_source.py）                   程序B（inference.py）
    ↓                                          ↓
1. 读取视频帧                               1. 创建Socket客户端
    ↓                                          ↓
2. 编码为JPEG                              2. 连接到程序A
    ↓                                          ↓
3. 用pickle序列化                          3. 接收数据长度（4字节）
    ↓                                          ↓
4. 发送长度（4字节）                       4. 接收图像数据
    ↓                                          ↓
5. 发送图像数据（通过Socket）              5. 反序列化数据
    ↓                                          ↓
6. 等待10Hz频率                            6. 解码JPEG为图像
    ↓                                          ↓
7. 重复步骤1-6                             7. YOLO推理
                                              ↓
                                          8. 显示结果
```

### 关键代码位置

#### 程序A发送数据（data_source.py 第91-108行）
```python
def send_frame(conn, frame):
    # 1. 将图像编码为JPEG格式（压缩）
    encode_param = [int(cv2.IMWRITE_JPEG_QUALITY), 90]
    success, encoded = cv2.imencode(".jpg", frame, encode_param)
    
    # 2. 用pickle序列化（转换为字节流）
    data = pickle.dumps(encoded, protocol=pickle.HIGHEST_PROTOCOL)
    size = len(data)
    
    # 3. 先发送数据长度（4字节），再发送实际数据
    conn.sendall(struct.pack("!I", size))  # 发送长度
    conn.sendall(data)                      # 发送数据
```

#### 程序B接收数据（inference.py 第40-59行）
```python
def recv_frame(conn):
    # 1. 先接收4字节的长度信息
    size_data = recv_exact(conn, 4)
    (size,) = struct.unpack("!I", size_data)
    
    # 2. 根据长度接收图像数据
    data = recv_exact(conn, size)
    
    # 3. 反序列化并解码
    encoded = pickle.loads(data)
    frame = cv2.imdecode(encoded, cv2.IMREAD_COLOR)
    return frame
```

### Socket通信的特点

- ✅ **优点**：
  - 简单易用，Python标准库支持
  - 跨平台（Linux/Windows）
  - 数据自动序列化/反序列化
  - 有连接状态，可以检测断开

- ❌ **缺点**：
  - 需要复制数据（发送端→内核→接收端）
  - 有序列化/反序列化开销
  - 需要编码/解码JPEG（压缩和解压）

---

## 🔄 共享内存 vs Socket 的区别

### Socket（当前方式）
```
程序A的内存 → 序列化 → 内核缓冲区 → 网络栈 → 内核缓冲区 → 反序列化 → 程序B的内存
     ↑                                                              ↓
     └─────────────────── 数据被复制了多次 ────────────────────────┘
```

### 共享内存（更高效）
```
程序A的内存 ←→ 共享内存区域 ←→ 程序B的内存
     ↑                              ↓
     └─────────── 直接访问同一块内存 ─────────┘
```

**共享内存的优势**：
- ⚡ **速度更快**：不需要复制数据，直接访问同一块内存
- 💾 **内存效率**：只占用一份内存空间
- 🚀 **适合大数据**：图像数据很大，共享内存避免复制开销

---

## 📝 如何改为共享内存？

如果要使用共享内存，需要使用 `multiprocessing.shared_memory` 模块（Python 3.8+）。

### 共享内存实现的关键步骤

1. **创建共享内存块**：程序A创建一块固定大小的共享内存
2. **写入图像数据**：将图像数据（numpy数组）直接写入共享内存
3. **通知程序B**：通过信号量或事件通知程序B有新数据
4. **读取图像数据**：程序B从共享内存读取数据
5. **同步机制**：使用锁或信号量避免读写冲突

### 注意事项

- 共享内存大小需要固定（需要知道最大图像尺寸）
- 需要同步机制（避免读写冲突）
- Windows和Linux实现略有不同

---

## 💡 总结

**当前代码使用的是 Unix Domain Socket，不是共享内存。**

- Socket方式：数据通过内核缓冲区传输，有复制开销
- 共享内存方式：两个程序直接访问同一块内存，无复制开销

如果你需要更高的性能（特别是高分辨率图像），可以考虑改为共享内存实现。

